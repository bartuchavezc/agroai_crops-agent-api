from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy import Table, Column, Integer, Float, DateTime, Index, Sequence
from src.app.database import shared_metadata

# TimescaleDB-specific table with composite primary key for hypertables
# This table is separate from the regular PostgreSQL weather_measurements table
weather_timeseries_table = Table(
    'weather_timeseries',  # Different table name for TimescaleDB
    shared_metadata,
    # Composite primary key optimized for TimescaleDB hypertables
    Column('timestamp', DateTime, nullable=False, primary_key=True),  # Time partitioning column
    Column('latitude', Float, nullable=False, primary_key=True),      # Space partitioning column  
    Column('longitude', Float, nullable=False, primary_key=True),     # Space partitioning column
    # Data columns
    Column('id', Integer, nullable=False),  # Regular field, NOT unique (TimescaleDB constraint)
    Column('temperature', Float, nullable=False),
    Column('humidity', Float, nullable=False),
    Column('precipitation', Float, nullable=False),
    Column('wind_speed', Float, nullable=False),
    Column('wind_direction', Float, nullable=False),
    Column('pressure', Float, nullable=False),
    Column('soil_moisture', Float, nullable=True),
    # TimescaleDB optimized indexes
    Index('ts_idx_time', 'timestamp'),  # Time-based queries
    Index('ts_idx_location', 'latitude', 'longitude'),  # Location-based queries
    Index('ts_idx_time_location', 'timestamp', 'latitude', 'longitude'),  # Combined queries
    Index('ts_idx_id', 'id'),  # ID-based lookups (regular index, not unique)
)

# Sequence for generating unique IDs in TimescaleDB table
weather_timeseries_id_seq = Sequence('weather_timeseries_id_seq')

@dataclass
class TimescaleWeatherSeries:
    """TimescaleDB-specific entity for time series weather data with metadata."""
    
    # Core weather data (matches the table structure)
    timestamp: datetime
    latitude: float
    longitude: float
    temperature: float
    humidity: float
    precipitation: float
    wind_speed: float
    wind_direction: float
    pressure: float
    soil_moisture: Optional[float] = None
    id: Optional[int] = None  # Will be generated by sequence
    
    # TimescaleDB metadata for optimization
    chunk_interval: timedelta = timedelta(days=1)
    compress_after: timedelta = timedelta(days=7)
    retention_period: timedelta = timedelta(days=1825)  # 5 years
    data_source: str = "smn"
    
    def to_insert_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for TimescaleDB insertion."""
        insert_dict = {
            'timestamp': self.timestamp,
            'latitude': self.latitude,
            'longitude': self.longitude,
            'temperature': self.temperature,
            'humidity': self.humidity,
            'precipitation': self.precipitation,
            'wind_speed': self.wind_speed,
            'wind_direction': self.wind_direction,
            'pressure': self.pressure,
            'soil_moisture': self.soil_moisture
        }
        # Only include id if it's set
        if self.id is not None:
            insert_dict['id'] = self.id
        return insert_dict
    
    @classmethod
    def from_weather_data(cls, weather_data, data_source: str = "smn"):
        """Create TimescaleWeatherSeries from domain WeatherData entity."""
        return cls(
            id=weather_data.id,
            timestamp=weather_data.timestamp,
            latitude=weather_data.latitude,
            longitude=weather_data.longitude,
            temperature=weather_data.temperature,
            humidity=weather_data.humidity,
            precipitation=weather_data.precipitation,
            wind_speed=weather_data.wind_speed,
            wind_direction=weather_data.wind_direction,
            pressure=weather_data.pressure,
            soil_moisture=weather_data.soil_moisture,
            data_source=data_source
        )
    
    def to_weather_data(self):
        """Convert to domain WeatherData entity."""
        from ...domain.entities import WeatherData
        return WeatherData(
            id=self.id,
            timestamp=self.timestamp,
            latitude=self.latitude,
            longitude=self.longitude,
            temperature=self.temperature,
            humidity=self.humidity,
            precipitation=self.precipitation,
            wind_speed=self.wind_speed,
            wind_direction=self.wind_direction,
            pressure=self.pressure,
            soil_moisture=self.soil_moisture
        )

@dataclass
class WeatherAggregation:
    """TimescaleDB aggregation result for weather data."""
    
    time_bucket: datetime
    latitude: float
    longitude: float
    
    # Aggregated values
    avg_temperature: Optional[float] = None
    min_temperature: Optional[float] = None
    max_temperature: Optional[float] = None
    avg_humidity: Optional[float] = None
    total_precipitation: Optional[float] = None
    avg_wind_speed: Optional[float] = None
    avg_pressure: Optional[float] = None
    
    # Metadata
    data_count: int = 0
    bucket_size: str = "1 hour"  # 1 hour, 1 day, 1 week, etc.

@dataclass
class ChunkInfo:
    """TimescaleDB chunk information for monitoring."""
    
    chunk_name: str
    chunk_schema: str
    table_name: str
    range_start: datetime
    range_end: datetime
    is_compressed: bool
    chunk_size: Optional[str] = None
    compression_ratio: Optional[float] = None

# TimescaleDB specific queries
class TimescaleQueries:
    """TimescaleDB specific SQL queries for time series operations."""
    
    @staticmethod
    def time_bucket_aggregate(bucket_size: str = "1 hour") -> str:
        """Generate time bucket aggregation query."""
        return f"""
        SELECT 
            time_bucket('{bucket_size}', timestamp) as time_bucket,
            latitude,
            longitude,
            AVG(temperature) as avg_temperature,
            MIN(temperature) as min_temperature,
            MAX(temperature) as max_temperature,
            AVG(humidity) as avg_humidity,
            SUM(precipitation) as total_precipitation,
            AVG(wind_speed) as avg_wind_speed,
            AVG(pressure) as avg_pressure,
            COUNT(*) as data_count
        FROM weather_timeseries
        WHERE timestamp >= :start_time AND timestamp <= :end_time
          AND latitude = :latitude AND longitude = :longitude
        GROUP BY time_bucket, latitude, longitude
        ORDER BY time_bucket
        """
    
    @staticmethod
    def get_chunk_info() -> str:
        """Get chunk information for monitoring."""
        return """
        SELECT 
            chunk_name,
            chunk_schema,
            table_name,
            range_start,
            range_end,
            is_compressed,
            pg_size_pretty(pg_total_relation_size(format('%I.%I', chunk_schema, chunk_name))) as chunk_size
        FROM timescaledb_information.chunks
        WHERE table_name = 'weather_timeseries'
        ORDER BY range_start DESC
        """
    
    @staticmethod
    def compress_chunks_older_than(days: int = 7) -> str:
        """Compress chunks older than specified days."""
        return f"""
        SELECT compress_chunk(i.chunk_name)
        FROM timescaledb_information.chunks i
        WHERE i.table_name = 'weather_timeseries'
          AND i.range_end < NOW() - INTERVAL '{days} days'
          AND NOT i.is_compressed
        """
    
    @staticmethod
    def latest_data_by_location() -> str:
        """Get latest data for each location using TimescaleDB last() function."""
        return """
        SELECT DISTINCT ON (latitude, longitude)
            latitude,
            longitude,
            last(temperature, timestamp) as latest_temperature,
            last(humidity, timestamp) as latest_humidity,
            last(precipitation, timestamp) as latest_precipitation,
            last(wind_speed, timestamp) as latest_wind_speed,
            last(wind_direction, timestamp) as latest_wind_direction,
            last(pressure, timestamp) as latest_pressure,
            last(soil_moisture, timestamp) as latest_soil_moisture,
            last(timestamp, timestamp) as latest_timestamp
        FROM weather_timeseries
        WHERE timestamp >= NOW() - INTERVAL '24 hours'
        GROUP BY latitude, longitude
        """
    
    @staticmethod
    def weather_stats_summary() -> str:
        """Get weather statistics summary using TimescaleDB functions."""
        return """
        SELECT 
            latitude,
            longitude,
            MIN(timestamp) as first_reading,
            MAX(timestamp) as last_reading,
            COUNT(*) as total_readings,
            AVG(temperature) as avg_temperature,
            STDDEV(temperature) as temp_stddev,
            AVG(humidity) as avg_humidity,
            SUM(precipitation) as total_precipitation,
            AVG(wind_speed) as avg_wind_speed
        FROM weather_timeseries
        WHERE timestamp >= :start_time AND timestamp <= :end_time
        GROUP BY latitude, longitude
        ORDER BY latitude, longitude
        """

# Helper functions for converting between domain and TimescaleDB entities
def weather_data_to_timescale_series(weather_data, data_source: str = "smn") -> TimescaleWeatherSeries:
    """Convert domain WeatherData to TimescaleDB series entity."""
    return TimescaleWeatherSeries.from_weather_data(weather_data, data_source)

def timescale_series_to_weather_data(series: TimescaleWeatherSeries):
    """Convert TimescaleDB series entity to domain WeatherData."""
    return series.to_weather_data() 